# Banana UI: A minimalist ISO C-compatible cross-platform graphical user interface infrastructure

The implementation of computer engineering should be as simple as possible. For example, the graphical interface of Linux that many people talk about, the more I study it, the more I feel bored. Is it necessary to make it so complicated? Isn't the graphical interface mainly just the screen, mouse, and keyboard? I want to do what I like, to simplify everything, and if my mental ability allows, I even want to design my own CPU, my own programming language, and my own compiler. Then according to my current ability, let's use C language to define a set of minimum operation sets, including reading and writing pixels, mouse and keyboard events. Corresponding to different software and hardware platforms, the minimum requirement is to implement these functions, and then they can compile and run smoothly. Advanced points, such as reading and writing pixels are too slow, so can you read and write whole blocks? No problem, these are optional operations, even if they are not implemented, I have default versions, and even mouse and keyboard events can be omitted if they are not needed. Images, fonts, windows, controls, input methods, etc. on the bottom layer are all written in C, or exported to a scripting language such as Lua, and the most concise method is chosen for each thing.

The goal is of course very ambitious. An extremely streamlined screen display/mouse/keyboard core can theoretically be extended to any platform with very little code. In order to improve performance and make most functions platform-independent, the mixed operation of layers is Use pure C code to operate in memory, and then flush to the device. When it comes to usage, the graphical interface of the operating system, the graphical interface of software, games, etc. can be used. For example, a set of commonly used functions can be realized under Framebuffer, which can completely replace the Linux text interface, just like the previous DosShell.

At present, the basic functions have been realized in the environment of Windows GDI, Linux Framebuffer, and X Window, including: reading and writing of pixels on the screen; mouse events; custom rectangular areas (I call them "blocks"); reading and writing of pixels of blocks ; Alpha blending operation between blocks; read and write blocks on the screen; embedded Unifont and other wide dot matrix fonts, the range can be customized, if the complete Plane 1 and 2 are included, then the compiled size is about 2M; support reading TGA format image files; and export all the above functions to Lua 5.1 environment. The following functions are to be implemented: Chinese input method; implement an open UI architecture similar to World of Warcraft under Lua 5.1; implement some semi-graphical programs similar to Dosshell.

The source code will not be made public for the time being to prevent malicious forks and random modifications. After the function is stable in the future, please feel free to chat privately if you have any suggestions. The sample program includes C language and Lua, and the command line is generally like this: "./xx <platform name> [[platform parameter] ...]", or "./minlua xx.lua <platform name> [[platform Parameters] ...]", minlua is a Lua interpreter without interactive functions, without additional dependencies such as readline and curse. The platform name under Windows is "windows_gdi", and there is no platform parameter. If the platform name under Linux is "linux_xorg", then there is no platform parameter. If it is "linux_framebuffer", then the parameters that need to be specified include the framebuffer and the device file name of the mouse. For example: "./minlua test_luabanana_1.lua linux_framebuffer /dev/fb0 /dev/input/event2", note that the framebuffer runs under the console instead of X Windows, and the user needs to have corresponding permissions. The easiest way is to set the user Join the video and input groups.

The drawing area is called "screen" in this architecture. If it is an unmanaged environment such as framebuffer, then it is the entire screen; under Windows and X Windows, a single window is used to simulate the "screen". Of course, this is naturally applicable to the development of single windowed application too. As for all the content in the "screen", it has nothing to do with Windows, X Window, etc.

See banana.h for all exported functions. I am used to using the full name of the function and variable name in natural word order, which is very simple as the name suggests. The basic process of the program is: first, banana_initialize() is initialized, and the parameters need to specify the event callback function (if not needed), platform name and platform parameters, as above; then your own initialization work, and finally banana_loop() enters the event loop. The event callback function responds to events such as screen, mouse, and keyboard, among which BANANA_EVENT_SCREEN_SIZE_CHANGED means that the screen size changes, such as resolution changes, Windows and X Windows window size changes, and the program needs to redraw the entire interface at this time. The function names in Lua are the same, and the usage is similar.

For other instructions, see the comments in the source code. If you donâ€™t understand Chinese, you can translate it yourself.
